<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;
using System.Collections.Generic;
using System.IO;
using BitcoinLite.Encoding;

<#
var objects = new[]{
	new { Name = "BlockHeader", Fields = new []
		{
			" 4;	version;		uint;		uint32_t;	Block version information, based upon the software version creating this block",
			"32;	prev_block_hash;uint256;	char[32];	The hash value of the previous block this particular block references",
			"32;	merkle_root_hash;uint256;	char[32];	The reference to a Merkle tree collection which is a hash of all transactions related to this block",
			" 4;	timestamp;		uint;		uint32_t;	A Unix timestamp recording when this block was created (Currently limited to dates before the year 2106!)",
			" 4;	bits;			Target;		uint32_t;	The calculated difficulty target being used for this block",
			" 4;	nonce;			uint;		uint32_t;	The nonce used to generate this block… to allow variations of the header and compute different hashes",
		}
	},
	new { Name = "Block", Fields = new []
		{
			"96;	header;			BlockHeader;blockheader;The block header",
			" ?;	txn_count;		VarInt;		var_int;	Number of transaction entries",
			" ?;	transactions;	Transaction[];tx[];		Block transactions, in format of \"tx\" command"
		}
	},
	new { Name = "Transaction", Fields = new []
		{
			" 4;	version;		uint;		uint32_t;	Transaction data format version",
			"1+;	tx_in_count;	VarInt;		var_int;	Number of Transaction inputs",
			"41+;	inputs;			TxIn[];		tx_in[];	A list of 1 or more transaction inputs or sources for coins",
			"1+;	tx_out_count;	VarInt;		var_int;	Number of Transaction outputs",
			"9+;	outputs;		TxOut[];	tx_out[];	A list of 1 or more transaction outputs or destinations for coins",
			" 4;	lock_time;		uint;		uint32;		"
		}
	},
	new { Name = "TxIn", Fields = new []
		{
			"36;	previous_output;OutPoint;	outpoint;	The previous output transaction reference, as an OutPoint structure",
			"1+;	script_length;	VarInt;		var_int;	The length of the signature script",
			" ?;	sig_script;		Script;		uchar[];	Computational Script for confirming transaction authorization",
			" 4;	sequence;		uint;		uint32_t;	Transaction version as defined by the sender. Intended for \"replacement\" of transactions when information is updated before inclusion into a block."
		}
	},
	new { Name = "OutPoint", Fields = new []
		{
			"32;	hash;			uint256;	char[32];	The hash of the referenced transaction.",
			" 4;	index;			uint;		uint32_t;	The index of the specific output in the transaction. The first output is 0, etc."
		}
	},
	new { Name = "TxOut", Fields = new []
		{
			" 8;	value;			long;		int64_t;	Transaction Value",
			"1+;	pk_script_length;VarInt;	var_int;	Length of the pk_script",
			" ?;	script_pub_key;	Script;	uchar[];	Usually contains the public key as a Bitcoin script setting up conditions to claim this output."
		}
	}

};#>

namespace BitcoinLite.Structures
{
<# foreach (var t in objects) { #>
	public partial class <#= t.Name #> : IVisitable
	{
		<#foreach(var p in Details(t.Fields)){
		#>// <#=p[4]#>
		public <#=p[2]#> <#=CapitalizeWords(p[1])#>	{ get; internal set; }

		<#}#>
		 
		public <#= t.Name #>(<#=Parameters(t.Fields)#>)
		{
<#foreach(var p in Details(t.Fields)){
			if(MustValidate(p[2])){#>
			if(<#=p[1]#> == null) throw new ArgumentNullException(nameof(<#=p[1]#>)); 
<#}}#>

<#foreach(var p in Details(t.Fields)){#>
			<#=CapitalizeWords(p[1])#> = <#=p[1]#>; 
<#}#>
		}

//		public static <#= t.Name #> FromByteArray(byte[] bytes)
//		{
//			var mem = new MemoryStream(bytes);
//			var reader = new BlockchainReader(new BitcoinBinaryReader(mem));
//			return reader.Read<#= t.Name #>();
//		}

//		public static <#= t.Name #> Parse(string hex)
//		{
//			return FromByteArray(Encoders.Hex.GetBytes(hex));
//		}
	}

<#
}
#>
}

<#+
public bool MustValidate(string t)
{
	switch(t){
		case "int":
		case "uint":
		case "long":
		case "ulong":
			return false;
	}
	return true;
}

public static string NetType(string t)
{
	if(t=="int") return "Int32";
	if(t=="uint") return "UInt32";
	if(t=="long") return "Int64";
	if(t=="ulong") return "UInt64";
	if(t=="uint256") return "UInt256";
	return t;
}

public static IEnumerable<string[]> Details(string[] fields)
{
	foreach(var p in fields){
		var xx = p.Split(';').Select(x=>x.Trim()).ToArray();
		if(xx[2].EndsWith("[]")) xx[2] = "IReadOnlyList<" + xx[2].Replace("[]", "") + ">";
		if(!xx[1].EndsWith("_count") && !xx[1].EndsWith("_length"))
		yield return xx;
	}
}

public static string CapitalizeWords(string value)
{
   if( value == null )
      throw new ArgumentNullException(nameof(value));
   if( value.Length == 0 )
      return value;

   StringBuilder result = new StringBuilder(value);
   result[0] = char.ToUpper(result[0]);
   for( int i = 1; i < result.Length; ++i )
   {
      if( result[i - 1]=='_' )
         result[i] = char.ToUpper(result[i]);
      else
         result[i] = char.ToLower(result[i]);
   }
   return result.ToString().Replace("_", "");
}
#>

<#+
public static string Parameters(string[] fields)
{
	string res = "";
	foreach(var p in Details(fields)){
		res += p[2] + " " + p[1] + ", ";
	}
	return res.Substring(0, res.Length-2);
}
#>
